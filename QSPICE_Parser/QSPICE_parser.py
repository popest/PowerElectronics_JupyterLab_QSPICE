# QSPICE parser
# modified on 23-Sep-2024

import os
import re
import subprocess
from datetime import datetime


def parse_and_generate_script(input_filename, output_filename):
    current_datetime = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    script_dir = os.path.dirname(os.path.abspath(__file__))

    input_file_path = os.path.join(script_dir, input_filename)
    output_file_path = os.path.join(script_dir, output_filename)
    # Use QSPICE to convert *.qsch to netlist *.cir
    exe_qux = os.path.expanduser(r"~\QSPICE\QUX.exe")
    # Run QUX
    exe_qux_out = subprocess.run([exe_qux, "-Netlist", f"{input_file_path}"])

    # change input file to generated *.cir file
    input_filename = input_filename.replace(".qsch", ".cir")
    input_file_path = os.path.join(script_dir, input_filename)

    with open(input_file_path, "r") as file:
        content = file.readlines()[1:]  # skip the first line

    # Delete *.cir file
    subprocess.run(["del", f"{input_file_path}"], shell=True)

    param_lines = []
    options_lines = []
    circuit_lines = []
    meas_lines = []
    model_lines = []
    analysis_lines = []
    param_args = set()
    excluded_param_lines = []
    processed_content = []

    excluded_params = {"TSTEP", "TSTART", "TSTOP"}

    for line in content:
        stripped_line = line.strip()
        if stripped_line.startswith(".param"):
            # Extract the variable name and value
            match = re.search(r"\.param\s+(\w+)\s*=\s*(\S+)", stripped_line)
            if match:
                param_name = match.group(1)
                param_value = match.group(2)
                if (
                    param_name not in excluded_params
                    and not param_name.lower().startswith("i_")
                ):
                    param_lines.append((param_name, param_value))
                    param_args.add(param_name)
                else:
                    excluded_param_lines.append(stripped_line)
        elif stripped_line.startswith(".options"):
            # Store options lines for inclusion in the function body
            options_lines.append(stripped_line)
        elif stripped_line.startswith(".meas"):
            # Store .meas lines for inclusion into function body
            meas_lines.append(stripped_line)
        elif stripped_line.startswith(".model"):
            # Store .model lines for inclusion into function body
            model_lines.append(stripped_line)
        elif stripped_line.startswith(".tran"):
            # Store .tran line for inclusion into function body
            analysis_lines.append(stripped_line)
        elif not stripped_line.startswith("."):
            # Store all other lines that do not start with '.'
            circuit_lines.append(line.strip())

    # indentation character
    indent = "    "
    # add required imports
    import_ = [
        f"#This file was autogenerated on {current_datetime}\n"
        "import os\n"
        "import subprocess\n"
        "import pandas as pd"
    ]
    # Generate the function signature with extracted param_args
    function_name = "QSPICE_" + input_filename.rsplit(".", 1)[0]
    # sort param_Args alphabetically without considering case
    param_args = sorted(param_args, key=str.lower)
    function_signature = (
        f"def {function_name}({', '.join(param_args)}, export_traces = None):\n"
    )

    # generate results list filled with zeros
    meas_count = len(meas_lines)
    meas_result_line = f"results = [{', '.join(['0.0']*meas_count)}]\n"

    # add for loop to search results file
    for_loop_code = f"{indent}for i, line in enumerate(results_lines):\n"
    for_loop_code += f"{indent}{indent}stripped_line = line.strip()\n"
    for_loop_code += f"{indent}{indent}match stripped_line:\n"
    for i, meas_line in enumerate(meas_lines):
        for_loop_code += f'{indent}{indent}{indent}case "{meas_line.lower()}:": \n'
        for_loop_code += f"{indent}{indent}{indent}{indent}results[{i}] = float(results_lines[i + 1])\n\n"
    for_loop_code += f"{indent}return [df,results]"

    # Result file processing lines
    processing_lines1 = [
        f"\n{indent}# Assume that QSPICE is installed in its default path for non-Admin user\n"
        f'{indent}exe_qspice64 = os.path.expanduser(r"~\QSPICE\QSPICE64.exe")\n'
        f'{indent}exe_qpost = os.path.expanduser(r"~\QSPICE\QPOST.exe")\n'
        f'{indent}exe_qux = os.path.expanduser(r"~\QSPICE\QUX.exe")\n\n'
        f"{indent}# run QSPICE Simulation\n"
        f'{indent}run_qspice64 = subprocess.run([exe_qspice64, "{input_filename}"])\n\n'
        f"{indent}# Run postprocess measurement\n"
        f'{indent}run_qpost = subprocess.run([exe_qpost, "{input_filename}", "-o", "results.txt"])\n\n'
        f'{indent}f = open("results.txt", "r")\n'
        f"{indent}results_lines = f.readlines()\n"
        f"{indent}f.close()\n"
    ]
    processing_lines2 = [
        f"{indent}# Run postprocess waveforms extraction\n"
        f"{indent}df = 0 \n"
        f"{indent}if export_traces:\n"
        f'{indent}{indent}run_qux = subprocess.run([exe_qux, "-Export", "{input_filename.replace(".cir", ".qraw")}", export_traces, "all", "CSV"])\n'
        f'{indent}{indent}df = pd.read_csv("{input_filename.replace(".cir", ".csv")}") \n'
        f'{indent}{indent}df.columns = df.columns.str.lower() \n\n'
        f'{indent}{indent}#Delete Exported Waveforms CSV File \n'
        f'{indent}{indent}subprocess.run(["del", "{input_filename.replace(".cir", ".csv")}"], shell=True) \n'
    ]

    processing_lines3 = [
        f"{indent}# Delete Results\n"
        f'{indent}subprocess.run(["del", "{input_filename.replace(".cir", ".qraw")}"], shell=True)\n\n'
        f"{indent}# Delete Netlist\n"
        f'{indent}subprocess.run(["del", "{input_filename}"], shell=True)\n\n'
        f"{indent}# Delete QPOST Results\n"
        f'{indent}subprocess.run(["del", "results.txt"], shell=True)\n'
    ]
    processing_lines = processing_lines1 + processing_lines2 + processing_lines3
    # generate the function body
    function_body = f"{indent}if export_traces is None:\n"
    function_body += f"{indent}{indent} export_traces = [] \n"
    function_body += f"{indent}#### Create circuit file ####\n"
    function_body += f'{indent}f = open("{input_filename}", "w", encoding="ascii", newline="\\n")\n\n{indent}#### Circuit Definition ####\n'
    function_body += f'{indent}f.write("* Auto-Generated Netlist File" + "\\n")\n'

    for circuit_line in circuit_lines:
        function_body += f'{indent}f.write("{circuit_line}" + "\\n")\n'

    function_body += f"\n{indent}#### Parameters ####\n"
    for param_name, param_value in param_lines:
        # Replace the value in the .param line with the argument
        function_body += (
            f'{indent}f.write(".param {param_name}=" + str({param_name}) + "\\n")\n'
        )

    # Add excluded params as they are
    for excluded_line in excluded_param_lines:
        function_body += f'{indent}f.write("{excluded_line}" + "\\n")\n'

    # Add .model line as they are
    function_body += f"\n{indent}#### Models ####\n"
    for model_line in model_lines:
        function_body += f'{indent}f.write("{model_line}" + "\\n")\n'

    # Add .options line as they are
    function_body += f"\n{indent}#### Spice Options ####\n"
    for options_line in options_lines:
        function_body += f'{indent}f.write("{options_line}" + "\\n")\n'

    # Add .meas lines as they are
    function_body += f"\n{indent}#### Measurement Definition ####\n"
    for i, meas_line in enumerate(meas_lines):
        function_body += f'{indent}f.write("{meas_line}" + "\\n") # results[{i}]\n'

    # Add SPICE analysis line as it is
    function_body += f"\n{indent}#### SPICE Analysis ####\n"
    for analysis_line in analysis_lines:
        function_body += f'{indent}f.write("{analysis_line}" + "\\n")\n'

    # END SPICE file
    function_body += f'\n{indent}f.write(".end")\n'
    # Close circuit file
    function_body += f"\n{indent}f.close()\n"

    # Add results list
    function_body += f"{indent}{meas_result_line}"

    # Combine the function signature and body
    function_code = (
        "\n".join(import_)
        + "\n"
        + "\n"
        + function_signature
        + function_body
        + "\n".join(processing_lines)
        + for_loop_code
    )

    # Write the processed content to the new Python script file
    with open(output_file_path, "w", encoding="utf-8") as file:
        file.write(function_code)
        file.writelines(processed_content)


if __name__ == "__main__":
    input_filename = "Full_Wave_REC_P_load.qsch"
    output_filename = "QSPICE_" + input_filename.rsplit(".", 1)[0] + ".py"
    parse_and_generate_script(input_filename, output_filename)
