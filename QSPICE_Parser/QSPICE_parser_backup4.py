# QSPICE parser
# modified on 22-Apr-2025
# updated path for run to keep all files within QSPICE subdirectory
# added feature to parsing .lib statement and .ac analysis

import os
import re
import subprocess
from datetime import datetime


def parse_and_generate_script(input_filename, output_filename):
    current_datetime = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    script_dir = os.path.dirname(os.path.abspath(__file__))

    input_file_path = os.path.join(script_dir, input_filename)
    output_file_path = os.path.join(script_dir, output_filename)
    # Use QSPICE to convert *.qsch to netlist *.cir
    exe_qux = os.path.expanduser(r"~\QSPICE\QUX.exe")
    # Run QUX
    exe_qux_out = subprocess.run([exe_qux, "-Netlist", f"{input_file_path}"])

    # change input file to generated *.cir file
    input_filename = input_filename.replace(".qsch", ".cir")
    input_file_path = os.path.join(script_dir, input_filename)

    with open(input_file_path, "r") as file:
        content = file.readlines()[1:]  # skip the first line

    # Delete *.cir file
    subprocess.run(["del", f"{input_file_path}"], shell=True)

    param_lines = []
    options_lines = []
    circuit_lines = []
    meas_lines = []
    model_lines = []
    lib_lines = []
    analysis_lines = []
    param_args = set()
    excluded_param_lines = []
    processed_content = []

    excluded_params = {"TSTEP", "TSTART", "TSTOP"}

    for line in content:
        stripped_line = line.strip()
        if stripped_line.startswith(".param"):
            # Extract the variable name and value
            match = re.search(r"\.param\s+(\w+)\s*=\s*(\S+)", stripped_line)
            if match:
                param_name = match.group(1)
                param_value = match.group(2)
                if (
                    param_name not in excluded_params
                    and not param_name.lower().startswith("i_")
                ):
                    param_lines.append((param_name, param_value))
                    param_args.add(param_name)
                else:
                    excluded_param_lines.append(stripped_line)
        elif stripped_line.startswith(".options"):
            # Store options lines for inclusion in the function body
            options_lines.append(stripped_line)
        elif stripped_line.startswith(".meas"):
            # Store .meas lines for inclusion into function body
            meas_lines.append(stripped_line)
        elif stripped_line.startswith(".model"):
            # Store .model lines for inclusion into function body
            model_lines.append(stripped_line)
        elif stripped_line.startswith(".lib"):
            # Store .lib lines for inclusion into function body
            lib_lines.append(stripped_line)
        elif stripped_line.startswith((".tran", ".ac")):
            # Store .tran or .ac line for inclusion into function body
            analysis_lines.append(stripped_line)
        elif not stripped_line.startswith("."):
            # Store all other lines that do not start with '.'
            circuit_lines.append(line.strip())

    # indentation character
    indent = "    "
    # add required imports
    import_ = [
        f"#This file was autogenerated on {current_datetime}\n"
        "import os\n"
        "import subprocess\n"
        "import pandas as pd\n"
        "import re\n"
        "import sys"
    ]
    # Generate the function signature with extracted param_args
    function_name = "QSPICE_" + input_filename.rsplit(".", 1)[0]
    # sort param_Args alphabetically without considering case
    param_args = sorted(param_args, key=str.lower)
    function_signature = (
        f"def {function_name}({', '.join(param_args)}, export_traces = None):\n"
    )

    # generate results dictionary filled with zeros
    # meas_count = len(meas_lines)
    meas_result_line = "results = { \n"
    for i, meas_line in enumerate(meas_lines):
        match = re.search(r"\.meas\s+(\w+)", meas_line)
        if match:
            meas_name = match.group(1)
            meas_result_line += f'{indent}{indent}"{meas_name}": 0,\n'
    meas_result_line += indent + "}"
    # meas_result_line = f"results = [{', '.join(['0.0']*meas_count)}]\n"

    # add for loop to search results file
    for_loop_code = f"{indent}for i, line in enumerate(results_lines):\n"
    for_loop_code += f"{indent}{indent}stripped_line = line.strip()\n"
    for_loop_code += f"{indent}{indent}match stripped_line:\n"
    for i, meas_line in enumerate(meas_lines):
        match = re.search(r"\.meas\s+(\w+)", meas_line)
        if match:
            meas_name = match.group(1)
            for_loop_code += f'{indent}{indent}{indent}case "{meas_line.lower()}:": \n'
            for_loop_code += f"{indent}{indent}{indent}{indent}results['{meas_name}'] = float(re.search(r'[-+]?\d*\.\d+|\d+', results_lines[i + 1])[0])\n\n"
    for_loop_code += f"{indent}return [df,results]"

    # Result file processing lines
    processing_lines1 = [
        f"\n{indent}# Assume that QSPICE is installed in its default path for non-Admin user\n"
        f'{indent}exe_qspice64 = os.path.expanduser(r"~\QSPICE\QSPICE64.exe")\n'
        f'{indent}exe_qpost = os.path.expanduser(r"~\QSPICE\QPOST.exe")\n'
        f'{indent}exe_qux = os.path.expanduser(r"~\QSPICE\QUX.exe")\n\n'
        f"{indent}# run QSPICE Simulation\n"
        f"{indent}try:\n"
        f'{indent}{indent}run_qspice64 = subprocess.Popen([exe_qspice64, "{input_filename}"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, cwd = base_dir, bufsize=1, universal_newlines=True)\n'
        f"{indent}{indent}for line in run_qspice64.stdout:\n"
        f'{indent}{indent}{indent}print(line, end="")\n'
        f"{indent}{indent}{indent}sys.stdout.flush()\n"
        f"\n"
        f"{indent}{indent}run_qspice64.wait()\n"
        f"\n"
        f"{indent}{indent}# Check exit code after process is done\n"
        f"{indent}{indent}if run_qspice64.returncode == 0:\n"
        f'{indent}{indent}{indent}print("QSPICE64 simulation completed successfully.")\n'
        f"{indent}{indent}{indent}print('*************** END ***************')\n"
        f"{indent}{indent}else:\n"
        f'{indent}{indent}{indent}print(f"QSPICE64 simulation failed with exit code {{run_qspice64.returncode}}.")\n'
        f'{indent}{indent}{indent}raise SystemExit("Terminating execution because simulation failed.")\n'
        # f"{indent}{indent}run_qspice64 = subprocess.run([exe_qspice64, file_path], capture_output=True, text=True, check=True)\n"
        # f"{indent}{indent}print('QSPICE64 ran successfully:')\n"
        # f"{indent}{indent}print(run_qspice64.stdout)\n"
        # f"{indent}{indent}print(run_qspice64.stderr)\n\n"
        f"{indent}except subprocess.CalledProcessError as e:\n"
        f"{indent}{indent}print('QSPICE64 exec output:')\n"
        f"{indent}{indent}print(e.stderr)\n\n"
        f"{indent}# Run postprocess measurement\n"
        f"{indent}try:\n"
        f'{indent}{indent}run_qpost = subprocess.run([exe_qpost, "{input_filename}", "-o", "results.txt"], capture_output=True, text=True, check=True, cwd = base_dir)\n'
        # f'{indent}{indent}run_qpost = subprocess.run([exe_qpost, "{input_filename}", "-o", "results.txt"], capture_output=True, text=True, check=True)\n'
        # f'{indent}{indent}run_qpost = subprocess.run([exe_qpost, file_path, "-o", "results.txt"], capture_output=True, text=True, check=True)\n'
        f"{indent}except subprocess.CalledProcessError as e:\n"
        f"{indent}{indent}print('QPOST exec output:')\n"
        f"{indent}{indent}print(e.stderr)\n\n"
        # f"{indent}print(run_qpost.stdout)\n"
        # f"{indent}print(run_qpost.stderr)\n\n"
        f'{indent}f = open(results_file_path, "r")\n'
        f"{indent}results_lines = f.readlines()\n"
        f"{indent}f.close()\n"
    ]
    processing_lines2 = [
        f"{indent}# Run postprocess waveforms extraction\n"
        f"{indent}df = 0 \n"
        f"{indent}if export_traces:\n"
        f'{indent}{indent}run_qux = subprocess.run([exe_qux, "-Export", "{input_filename.replace(".cir", ".qraw")}", export_traces, "all", "CSV"], cwd = base_dir)\n'
        f"{indent}{indent}df = pd.read_csv(csv_file_path) \n"
        f"{indent}{indent}df.columns = df.columns.str.lower() \n\n"
        f"{indent}{indent}#Delete Exported Waveforms CSV File \n"
        f'{indent}{indent}subprocess.run(["del", "{input_filename.replace(".cir", ".csv")}"], shell=True, cwd = base_dir) \n'
    ]

    processing_lines3 = [
        f"{indent}# Delete Results\n"
        f'{indent}subprocess.run(["del", "{input_filename.replace(".cir", ".qraw")}"], shell=True, cwd = base_dir)\n\n'
        f"{indent}# Delete Netlist\n"
        f'{indent}subprocess.run(["del", "{input_filename}"], shell=True, cwd = base_dir)\n\n'
        # f'{indent}subprocess.run(["del", file_path], shell=True, cwd = base_dir)\n\n'
        f"{indent}# Delete QPOST Results\n"
        f'{indent}subprocess.run(["del", "results.txt"], shell=True, cwd = base_dir)\n'
    ]
    processing_lines = processing_lines1 + processing_lines2 + processing_lines3
    # generate the function body
    function_body = f"{indent}if export_traces is None:\n"
    function_body += f"{indent}{indent} export_traces = [] \n"
    function_body += f"{indent}#### Create circuit file ####\n"
    function_body += f'{indent}cir_file_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "{input_filename}")\n'
    function_body += f'{indent}results_file_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "results.txt")\n'
    function_body += f'{indent}csv_file_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "{input_filename.replace(".cir", ".csv")}")\n'
    function_body += f"{indent}base_dir = os.path.dirname(os.path.realpath(__file__))\n"
    # function_body += f'{indent}QSPICE_dir = os.path.join(base_dir, "QSPICE")\n'
    function_body += f'{indent}f = open(cir_file_path, "w", newline="\\n")\n\n{indent}#### Circuit Definition ####\n'
    function_body += f'{indent}f.write("* Auto-Generated Netlist File" + "\\n")\n'

    for circuit_line in circuit_lines:
        function_body += f'{indent}f.write("{circuit_line}" + "\\n")\n'

    function_body += f"\n{indent}#### Parameters ####\n"
    for param_name, param_value in param_lines:
        # Replace the value in the .param line with the argument
        function_body += (
            f'{indent}f.write(".param {param_name}=" + str({param_name}) + "\\n")\n'
        )

    # Add excluded params as they are
    for excluded_line in excluded_param_lines:
        function_body += f'{indent}f.write("{excluded_line}" + "\\n")\n'

    # Add .model line as they are
    function_body += f"\n{indent}#### Models ####\n"
    for model_line in model_lines:
        function_body += f'{indent}f.write("{model_line}" + "\\n")\n'

    # Add .lib line as they are
    function_body += f"\n{indent}#### Libs ####\n"
    for lib_line in lib_lines:
        escaped = lib_line.replace("\\", "\\\\").replace(
            '"', '\\"'
        )  # escape backslashes and quotes
        function_body += f'{indent}f.write("{escaped}" + "\\n")\n'

    # Add .options line as they are
    function_body += f"\n{indent}#### Spice Options ####\n"
    for options_line in options_lines:
        function_body += f'{indent}f.write("{options_line}" + "\\n")\n'

    # Add .meas lines as they are
    function_body += f"\n{indent}#### Measurement Definition ####\n"
    for i, meas_line in enumerate(meas_lines):
        function_body += f'{indent}f.write("{meas_line}" + "\\n") # results[{i}]\n'

    # Add SPICE analysis line as it is
    function_body += f"\n{indent}#### SPICE Analysis ####\n"
    for analysis_line in analysis_lines:
        function_body += f'{indent}f.write("{analysis_line}" + "\\n")\n'

    # END SPICE file
    function_body += f'\n{indent}f.write(".end")\n'
    # Close circuit file
    function_body += f"\n{indent}f.close()\n"

    # Add results list
    function_body += f"{indent}{meas_result_line}"

    # Combine the function signature and body
    function_code = (
        "\n".join(import_)
        + "\n"
        + "\n"
        + function_signature
        + function_body
        + "\n".join(processing_lines)
        + for_loop_code
    )

    # Write the processed content to the new Python script file
    with open(output_file_path, "w", encoding="utf-8") as file:
        file.write(function_code)
        file.writelines(processed_content)


if __name__ == "__main__":
    input_filename = "Full_Wave_REC_P_load.qsch"
    output_filename = "QSPICE_" + input_filename.rsplit(".", 1)[0] + ".py"
    parse_and_generate_script(input_filename, output_filename)
