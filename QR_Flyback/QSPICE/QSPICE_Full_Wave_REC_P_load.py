#This file was autogenerated on 2025-04-27 22:03:08
import os
import subprocess
import pandas as pd
import re
import sys

def QSPICE_Full_Wave_REC_P_load(Cf, ESR, freq, fwd, Pin, rdiff, VAC_rms, export_traces = None):
    if export_traces is None:
         export_traces = [] 
    #### Create circuit file ####
    cir_file_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "Full_Wave_REC_P_load.cir")
    results_file_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "results.txt")
    csv_file_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "Full_Wave_REC_P_load.csv")
    base_dir = os.path.dirname(os.path.realpath(__file__))
    f = open(cir_file_path, "w", newline="\n")

    #### Circuit Definition ####
    f.write("* Auto-Generated Netlist File" + "\n")
    f.write("D1 N01 out REC" + "\n")
    f.write("D2 N02 out REC" + "\n")
    f.write("D3 0 N02 REC" + "\n")
    f.write("D4 0 N01 REC" + "\n")
    f.write("V1 N01 N02 SIN 0 {sqrt(2)*VAC_rms} {freq}" + "\n")
    f.write("C1 N03 0 {Cf}" + "\n")
    f.write("B1 out 0 R=if(time>2/freq,(V(out)*V(out))/{Pin},0)" + "\n")
    f.write("R1 out N03 {ESR}" + "\n")

    #### Parameters ####
    f.write(".param Pin=" + str(Pin) + "\n")
    f.write(".param Cf=" + str(Cf) + "\n")
    f.write(".param VAC_rms=" + str(VAC_rms) + "\n")
    f.write(".param fwd=" + str(fwd) + "\n")
    f.write(".param rdiff=" + str(rdiff) + "\n")
    f.write(".param freq=" + str(freq) + "\n")
    f.write(".param ESR=" + str(ESR) + "\n")
    f.write(".param TSTEP = {(1/freq)/1000}" + "\n")
    f.write(".param TSTOP = {600*1/freq}" + "\n")
    f.write(".param TSTART = {TSTOP-6/freq}" + "\n")

    #### Models ####
    f.write(".model REC D(Vfwd={fwd},Ron={rdiff},Cjo=10p)" + "\n")

    #### Libs ####
    f.write(".lib C:\\Users\\Stani\\QSPICE\\Diode.txt" + "\n")

    #### Spice Options ####
    f.write(".options savepowers=1" + "\n")
    f.write(".options trtol=1" + "\n")

    #### Measurement Definition ####
    f.write(".meas I_AC_RMS rms I(V1)" + "\n") # results[0]
    f.write(".meas I_D_RMS rms I(D1)" + "\n") # results[1]
    f.write(".meas I_D_AVG avg I(D1)" + "\n") # results[2]
    f.write(".meas P_D_AVG avg P(D1)" + "\n") # results[3]
    f.write(".meas I_Cin_RMS rms I(C1)" + "\n") # results[4]
    f.write(".meas VOUT_AVG AVG V(out)" + "\n") # results[5]

    #### SPICE Analysis ####
    f.write(".tran 0 TSTOP TSTART TSTEP" + "\n")

    f.write(".end")

    f.close()
    results = { 
        "I_AC_RMS": 0,
        "I_D_RMS": 0,
        "I_D_AVG": 0,
        "P_D_AVG": 0,
        "I_Cin_RMS": 0,
        "VOUT_AVG": 0,
    }
    # Assume that QSPICE is installed in its default path for non-Admin user
    exe_qspice64 = os.path.expanduser(r"~\QSPICE\QSPICE64.exe")
    exe_qpost = os.path.expanduser(r"~\QSPICE\QPOST.exe")
    exe_qux = os.path.expanduser(r"~\QSPICE\QUX.exe")

    # run QSPICE Simulation
    try:
        run_qspice64 = subprocess.Popen([exe_qspice64, "Full_Wave_REC_P_load.cir"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, cwd = base_dir, bufsize=1, universal_newlines=True)
        for line in run_qspice64.stdout:
            print(line, end="")
            sys.stdout.flush()

        run_qspice64.wait()

        # Check exit code after process is done
        if run_qspice64.returncode == 0:
            print("QSPICE64 simulation completed successfully.")
            print('*************** END ***************')
        else:
            print(f"QSPICE64 simulation failed with exit code {run_qspice64.returncode}.")
            raise SystemExit("Terminating execution because simulation failed.")
    except subprocess.CalledProcessError as e:
        print('QSPICE64 exec output:')
        print(e.stderr)

    # Run postprocess measurement
    try:
        run_qpost = subprocess.run([exe_qpost, "Full_Wave_REC_P_load.cir", "-o", "results.txt"], capture_output=True, text=True, check=True, cwd = base_dir)
    except subprocess.CalledProcessError as e:
        print('QPOST exec output:')
        print(e.stderr)

    f = open(results_file_path, "r")
    results_lines = f.readlines()
    f.close()

    # Run postprocess waveforms extraction
    df = 0 
    if export_traces:
        run_qux = subprocess.run([exe_qux, "-Export", "Full_Wave_REC_P_load.qraw", export_traces, "all", "CSV"], cwd = base_dir)
        df = pd.read_csv(csv_file_path) 
        df.columns = df.columns.str.lower() 

        #Delete Exported Waveforms CSV File 
        subprocess.run(["del", "Full_Wave_REC_P_load.csv"], shell=True, cwd = base_dir) 

    # Delete Results
    subprocess.run(["del", "Full_Wave_REC_P_load.qraw"], shell=True, cwd = base_dir)

    # Delete Netlist
    subprocess.run(["del", "Full_Wave_REC_P_load.cir"], shell=True, cwd = base_dir)

    # Delete QPOST Results
    subprocess.run(["del", "results.txt"], shell=True, cwd = base_dir)
    for i, line in enumerate(results_lines):
        stripped_line = line.strip()
        match stripped_line:
            case ".meas i_ac_rms rms i(v1):": 
                results['I_AC_RMS'] = float(re.search(r'[-+]?\d*\.\d+|\d+', results_lines[i + 1])[0])

            case ".meas i_d_rms rms i(d1):": 
                results['I_D_RMS'] = float(re.search(r'[-+]?\d*\.\d+|\d+', results_lines[i + 1])[0])

            case ".meas i_d_avg avg i(d1):": 
                results['I_D_AVG'] = float(re.search(r'[-+]?\d*\.\d+|\d+', results_lines[i + 1])[0])

            case ".meas p_d_avg avg p(d1):": 
                results['P_D_AVG'] = float(re.search(r'[-+]?\d*\.\d+|\d+', results_lines[i + 1])[0])

            case ".meas i_cin_rms rms i(c1):": 
                results['I_Cin_RMS'] = float(re.search(r'[-+]?\d*\.\d+|\d+', results_lines[i + 1])[0])

            case ".meas vout_avg avg v(out):": 
                results['VOUT_AVG'] = float(re.search(r'[-+]?\d*\.\d+|\d+', results_lines[i + 1])[0])

    return [df,results]